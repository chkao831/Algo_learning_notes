```
在上一章中，我们讲到了一个O(logn)时间复杂度的算法，二分算法。只需要O(logn)的时间就可以成功进行搜索。而我们在第四章的时候，就已经讲到了，我们可以通过时间复杂度来推测算法，当我们发现需要时间复杂度为<O(N)的算法时，我们可以考虑使用二分搜索来解决问题。但是如果题目不能用二分搜索来解决，我们该使用什么算法来解决呢？
    今天我们就来看一下几种同为logn时间复杂度的算法——快速幂算法、辗转相除法以及另外两种小于O(N)时间复杂度的算法——质因数分解和分块检索法。
    
接下来我们来看一下辗转相除法
辗转相除法
算法介绍

辗转相除法， 又名欧几里德算法， 是求最大公约数的一种方法。它的具体做法是：用较大的数除以较小的数，再用除数除以出现的余数（第一余数），再用第一余数除以出现的余数（第二余数），如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。
代码

Java:
public int gcd(int big, int small) {
    if (small != 0) {
        return gcd(small, big % small);
    } else {
        return big;
    }
}
Python:
def gcd(big, small):
    if small != 0:
        return gcd(small, big % small)
    else:
        return big
C++:
int gcd(int big, int small) {
    if (small != 0) {
        return gcd(small, big % small);
    } else {
        return big;
    }
}

算上之前学的二分算法，现在大家的技能书里面应该已经有了3个时间复杂度为O(logn)的算法了，接下来我们来看一个比较特殊，而且各大公司都特别喜欢考的问题——求两个排序数组的中位数。

两个排序数组的中位数
题目描述

在两个排序数组中，求他们合并到一起之后的中位数
时间复杂度要求：O(log(n+m))，其中 n, m 分别为两个数组的长度
解法

基于 FindKth 的算法。整体思想类似于 median of unsorted array 可以用 find kth from unsorted array 的解题思路。
基于二分的方法。二分 median 的值，然后再用二分法看一下两个数组里有多少个数小于这个二分出来的值。

算法描述
先将找中点问题转换为找第 k 小的问题，这里直接令k = (n + m) / 2。那么目标是在 logk = log((n+m)/2) = log(n+m) 的时间内找到A和B数组中从小到大第 k 个。
比较 A 数组的第 k/2 小和 B 数组的第 k/2 小的数。谁小，就扔掉谁的前 k/2 个数。
将目标寻找第 k 小修改为寻找第 (k-k/2) 小
回到第 2 步继续做，直到 k == 1 或者 A 数组 B 数组里已经没有数了。
F.A.Q
Q: 如何 O(1) 时间移除数组的前 k/2 个数？
A: 给两个数组一个起始位置的标记参数（相当于一个offset，偏移位），把这个起始位置 + k/2 就可以了。
Q: 不是让我们找中点么？怎么变成了找第 k 小？
A: 找第 k 小如果能在 log(k) 的时间内解决，那么找中点就可以在 log( (n+m)/2 ) 的时间内解决。
Q.如何证明谁的第 k/2 个数比较小就扔掉谁的前 k/2 个数这个理论？
A: 直观的，我们看一个例子
A=[1,3,5,7]
B=[2,4,6,8]
假如我们要找第 4 小。也就是 k = 4。算法会去比较两个数组中第 2 小的数。也就是 A[1]=3 和 B[1]=4 这两个数的大小。然后会发现，3比较小，然后就决定扔掉 A 的前 k/2 = 2 个数。也就是，接下来，需要去找
A=[5,7]
B=[2,4,6,8]
中的第 k-k/2=2 小的数。这里我们扔掉了 [1,3]，扔掉的这些数中，一定不会包含我们要找的第 4 小的数——4。因为从位置上，他们在 A 和 B合并到一起之后，都会排在 4 的前面。
抽象的证明一下：
我们需要回顾一下 Merge Two Sorted Arrays 这道题目。算法的做法是，每一次比较两个数组中比较小的数，然后谁小，谁先被拿出来，放到最后的合并结果中。那么假设 A 和 B中 A[k/2 - 1] <= B[k/2 - 1]（反之同理）。我们会决定扔掉A[0..k/2-1]，因为这些数在 A 与 B 做简单的 Merge 的过程中，会优先于目标第 k 个数现出来。为什么？因为既然A[k/2-1] <= B[k/2-1]，那么当我们用最简单的 Merge Two Sorted Arrays 的算法一个个从A和B里拿数出来的时候，当 A[k/2 - 1] 出来的时候，B[k/2 - 1] 一定还没有被拿出来，那么此时A里出来了 k/2 个数，B里出来的数一定不够 k/2 个（因为第 k/2 个数都还没出来），所以加起来总共出来的数肯定不够k个，所以第k小的数一定还留在AB数组中。
因此我们证明了：扔掉较小的一部分的前 k/2 个数，不会扔掉要找的第 k 小的数。

基于二分的算法
算法描述

我们需要先确定二分的上下界限，由于两个数组 A, B 均有序，所以下界为 min(A[0], B[0])，上界为 max(A[A.length - 1], B[B.length - 1]).
判断当前上下界限下的 mid(mid = (start + end) / 2) 是否为我们需要的答案；这里我们可以分别对两个数组进行二分来找到两个数组中小于等于当前 mid 的数的个数cnt1与 cnt2，sum = cnt1 + cnt2 即为 A 跟 B 合并后小于等于当前mid的数的个数.
如果 sum < k，即中位数肯定不是 mid，应该大于 mid，更新 start 为 mid，否则更新 end 为 mid，之后再重复第二步
当不满足 start + 1 < end 这个条件退出二分循环时，再分别判断一下start跟 end ，最终返回符合要求的那个数即可

算法详解

如果对该算法有点疑问，我们下面来详细讲解一下：
这一题如果用二分法来做，其实就是一个二分答案的过程
首先我们已经得到了上下界限，那么答案必定是在这个上下界限中的，需要实现的就是从这个歌上下界限中找出答案
我们每次取的 mid，其实就是我们每次在假设答案为 mid，二分的过程就是不断的推翻这个假设，然后再假设新的答案
需要满足的条件为：
上面算法描述中的 sum 需要等于 k，这里的 k = (A.length + B.length) / 2. 如果 sum < k，很明显当前的 mid 偏小，需要增大，否则就说明当前的 mid 偏大，需要缩小.
最终在 start 与 end 相邻的时候退出循环，判断 start 跟 end 哪个符合条件即可得到最终结果

看完了logn时间复杂度的算法和题目，接下来我们来看一下时间复杂度为sqrt(n)的算法。
首先第一个算法是素因子分解的算法。

分解质因数
以 sqrt{n} 为时间复杂度的算法并不多见，最具代表性的就是分解质因数了。
具体步骤

记up = sqrt{n}，作为质因数k的上界, 初始化k=2。
当k <= up 且 n不为1 时，执行步骤3，否则执行步骤4。
当n被k整除时，不断整除并覆盖n，同时结果中记录k，直到n不能整出k为止。之后k自增，执行步骤2。
当n不为1时，把n也加入结果当中，算法结束。
几点解释

不需要判定k是否为质数，如果k不为质数，且能整出n时，n早被k的因数所除。故能整除n的k必是质数。
为何引入up？为了优化性能。当k大于up时，k已不可能整除n，除非k是n自身。也即为何步骤4判断n是否为1，n不为1时必是比up大的质数。
步骤2中，也判定n是否为1，这也是为了性能，当n已为1时，可早停。
代码
Java:
public List<Integer> primeFactorization(int n) {
    List<Integer> result = new ArrayList<>();
    int up = (int) Math.sqrt(n);
    
    for (int k = 2; k <= up && n > 1; ++k) {
        while (n % k == 0) {
            n /= k;
            result.add(k);
        }
    }
    
    if (n > 1) {
        result.add(n);
    }
    
    return result;
}
Python:
def primeFactorization(n):
    result = []
    up = int(math.sqrt(n));
    
    k = 2
    while k <= up and n > 1: 
        while n % k == 0:
            n //= k
            result.append(k)
        k += 1
            
    if n > 1:
        result.append(n)
        
    return result
C++:
vector<int> primeFactorization(int n) {
    vector<int> result;
    int up = (int)sqrt(n);
    
    for (int k = 2; k <= up && n > 1; ++k) {
        while (n % k == 0) {
            n /= k;
            result.push_back(k);
        }
    }
    
    if (n > 1) {
        result.push_back(n);
    }
    
    return result;
}
复杂度分析

最坏时间复杂度O(sqrt (n) )。当n为质数时，取到其最坏时间复杂度。
空间复杂度O(log(n)), 当n质因数很多时，需要空间大，但总不会多于O(log(n))个

延伸

质因数分解有一种更快的算法，叫做Pollard Rho快速因数分解。该算法时间复杂度为O(n^{1/4})，其理解起来稍有难度，有兴趣的同学可以进行自学，参考链接:https://wenku.baidu.com/view/3db5c7a6ad51f01dc381f156.html


在数组中，二分找到插入位置，将需要插入的数字插入到该位置中，时间复杂度是多少。
O(n)

能不能通过链表，使得每次插入一个数字后，二分找到这个数字所在的位置，并O(1)进行插入，这样插入的时间复杂度就会变成O(logn)?
不可以


```
